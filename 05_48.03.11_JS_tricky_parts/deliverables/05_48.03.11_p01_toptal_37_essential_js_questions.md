
# Result Summary (Incorrect)


# Responses
1. What is a potential pitfall with using typeof bar === "object" to determine if bar is an object? How can this pitfall be avoided?
Both `array`js types and empty `object`js evaluate to "object". This pitfall can be avoided with checking against `Object.getPrototypeOf(bar)`js.

2. What will the code below output to the console and why?
```js
(function(){
  var a = b = 3;
})();

console.log("a defined? " + (typeof a !== 'undefined'));
console.log("b defined? " + (typeof b !== 'undefined'));
```

This is a weird assignment pattern; haven't seen it done before but it is not a valid expression. 
```js
//	> a defined? false
//	> b defined? false
```

3. What will the code below output to the console and why?
```js
var myObject = {
    foo: "bar",
    func: function() {
        var self = this;
        console.log("outer func:  this.foo = " + this.foo);
        console.log("outer func:  self.foo = " + self.foo);
        (function() {
            console.log("inner func:  this.foo = " + this.foo);
            console.log("inner func:  self.foo = " + self.foo);
        }());
    }
};
myObject.func();
```

In the outer function, when it still has access to the object name space, it will refer to `"bar"`. `this`js in the outer function refers to `myObject`. However, the next function call, when called by `myObject.func()`js, `this`js refers to `myObject` and thus still knows of "bar" but `self` is meaningless.
```js
//	outer func:  this.foo = bar
//	outer func:  self.foo = bar
//	inner func:  this.foo = bar
//	inner func:  self.foo = undefined
```

4. What is the significance of, and reason for, wrapping the entire content of a JavaScript source file in a function block?
I don't know... encapsulation?

5. What is the significance, and what are the benefits, of including 'use strict' at the beginning of a JavaScript source file?
I don't know. I have never found it necessary to do so.

6. Consider the two functions below. Will they both return the same thing? Why or why not?
```js
function foo1()
{
  return {
      bar: "hello"
  };
}

function foo2()
{
  return
  {
      bar: "hello"
  };
}
```

**No**. The last one will return `undefined` because of JavaScript automatic semicolon insertion.

7. What will the code below output? Explain your answer.
```js
console.log(0.1 + 0.2);
console.log(0.1 + 0.2 == 0.3);
```

The first one will return `0.3` or `0.300....1` depending on how floating point Math is working in JavaScript at the time; the last will return `false` because JavaScript implements decimal-point numbers with floating-point numbers instead of fixed-point numbers.

8. In what order will the numbers 1-4 be logged to the console when the code below is executed? Why?
```js
(function() {
    console.log(1); 
    setTimeout(function(){console.log(2)}, 1000); 
    setTimeout(function(){console.log(3)}, 0); 
    console.log(4);
})();
```
It will output:
```js
//	1	
//	4
//	3
//	2
```
I am sure of the order of `1`, `2`, and `4` because printing `2` and `3` are done through an asynchronous call. I am just guessing that the 0 ms timeout sets up an async call while `4` is logged.

9. Write a simple function (less than 160 characters) that returns a boolean indicating whether or not a string is a palindrome.

I am not using arrow notation because `let ... => {}`
Becaus I am restricted to 160 characters,
- It is my personal preference to use `const`js when defining the arrow function but I am saving one character by using `let`js. Regardless of the arrow function shortcut, I also prefer to wrap the parameters in parentheses regardless.
- Let `a` = `testPalindrome`, the function name.
- let `s` = `inputString`, the string to test
- let `h` = `_testPalindrome`, a helper function to recurse on
- let `i` = `index`, something to keep track of the string
- The following is **152 characters** (assumes lowercase input because `=s.toLowerCase()` takes 16 characters)
```js
let a = s => {
function h(i){
if(i==Math.ceil(s.length-i)/2)) return true;
if(s[i]==s[s.length-i]) return true && h(i+1);
return false;
}
return h(0);
}
```

Preferably it would have been, without character limits:
```js
function testPalindrome(inputString)

	inputString = inputString.toLowerCase();

	function _testPalindrome(index=0){

		if(i==Math.ceil(s.length-index)/2))
			return true;

		if(inputString[index]==inputString[inputString.length-index])
			return true && _testPalindrome((index+1);
		
		return false;

	}

	return _testPalindrome(0);

}
```

10. Write a sum method which will work properly when invoked using either syntax below.
```js
console.log(sum(2,3));   // Outputs 5
console.log(sum(2)(3));  // Outputs 5\
```

Oh, shoot. It looks like Python lambda function stuff...

11. Consider the following code snippet:
```js
for (var i = 0; i < 5; i++) {
	var btn = document.createElement('button');
	btn.appendChild(document.createTextNode('Button ' + i));
	btn.addEventListener('click', function(){ console.log(i); });
	document.body.appendChild(btn);
}
```
a. What gets logged to the console when the user clicks on “Button 4” and why?
b. Provide one or more alternate implementations that will work as expected.

a. When the user clicks on "Button 4", it will log "4". because i = 4. Sure, the follow-up question betrays this answer, but I am sticking with it.
```js
for(let i=0; i<5; i++){

	let button = document.createElement('button');
	button.appendChild(document.createTextNode(`Button ${i}`));
	button.addEventListener('click', () => {
		console.log(i);
	});

	document.body.appendChild(button);

}
```

12. Assuming `d` is an "empty" object in scope, say:
```js
var d = {};
```
...what is accomplished using the following code?
```js
[ 'zebra', 'horse' ].forEach(function(k) {
	d[k] = undefined;
});
```

It yields thte object:
```js
d {
	'zebra': undefined,
	'horse': undefined
}
```

13. What will the code below output to the console and why?
```js
var arr1 = "john".split('');
var arr2 = arr1.reverse();
var arr3 = "jones".split('');
arr2.push(arr3);
console.log("array 1: length=" + arr1.length + " last=" + arr1.slice(-1));
console.log("array 2: length=" + arr2.length + " last=" + arr2.slice(-1));
```

```js
//arr1 = [j, o, h, n]
//arr2 = [n, h, o, j]
```
The output is, assuming JavaScript supports array backwards slicing like Python:
```js
//	array 1: length=4 last=n
//	array 2: length=9 last=s
```

14. What will the code below output to the console and why ?
```js
console.log(1 +  "2" + "2");
console.log(1 +  +"2" + "2");
console.log(1 +  -"1" + "2");
console.log(+"1" +  "1" + "2");
console.log( "A" - "B" + "2");
console.log( "A" - "B" + 2);
```

Oh great. Loose typing on JavaScript, um:
```js
//	5
//	5
//	2
//	112
//	ascii(A)-ascii(B)+2 whatever that is
//	ascii(A)-ascii(B)+2
```
I don't know, I am just guessing.

15. The following recursive code will cause a stack overflow if the array list is too large. How can you fix this and still retain the recursive pattern?
```js
var list = readHugeList();

var nextListItem = function() {
	var item = list.pop();

	if (item) {
		// process the list item...
		nextListItem();
	}
};
```

Use a `continue` iterator. I forgot how to initialize it but that is where I'd start looking.

16. What is a "closure" in JavaScript? Provide an example.

Closure in JavaScript is returning a nested function ("inner function") that has maintains its state after the function that returned the inner function has gone. For example,
```js
function outerFunction(){

	const count = 0;

	return innerFunction(){
		console.log(count+1);
	}

}
```

17. What would the following lines of code output to the console?
```js
console.log("0 || 1 = "+(0 || 1));
console.log("1 || 2 = "+(1 || 2));
console.log("0 && 1 = "+(0 && 1));
console.log("1 && 2 = "+(1 && 2));
```
Explain your answer.

The following lines will output:
```js
//	"0 || 1 = true"
//	"1 || 2 = true"
//	"0 && 1 = false"
//	"1 && 2 = true"
```
Because `0` is falsey, `1` and `2` is truthy. `||` is a logical OR, `&&` is a logical AND.

18. What will be the output when the following code is executed? Explain.
```js
console.log(false == '0')
console.log(false === '0')
```

The following will output:
```js
//	false
//	false
```
For `String`js, only an empty string is falsey, the string `"0"` is truthy. Because both statements are false, the equality operators both fail, the latter checking if it is the same object.

19. What is the output out of the following code? Explain your answer.
```js
var a={},
    b={key:'b'},
    c={key:'c'};

a[b]=123;
a[c]=456;

console.log(a[b]);
```

The following output would be:
```js
a{'[Object]': 123}
```
where `Object` will be a stringified object `b` because JavaScript `object`js-literals stringify the keys.

20. What will the following code output to the console:
```js
console.log((function f(n){return ((n > 1) ? n * f(n-1) : n)})(10));
```
Explain your answer.


```js
console.log(
	(function f(n){
		return ((n > 1) ? n * f(n-1) : n)
	})(10)
);
```

The following will output 10 factorial, 10*9*8*7*6*5*4*3*2*1 = 7*10*72*720 = 7*720^2 = 7(490000+28000+400)=7(518400)=3628800:
```js
>	3628800
```

21. Consider the code snippet below. What will the console output be and why?
```js
(function(x) {
    return (function(y) {
        console.log(x);
    })(2)
})(1);
```

```js
>	1
```
because the inner function saves `x` as 1 from the outer function's namesapce. the parameter `2` on `y` has no effect on `x`.

22. What will the following code output to the console and why:
```js
var hero = {
    _name: 'John Doe',
    getSecretIdentity: function (){
        return this._name;
    }
};

var stoleSecretIdentity = hero.getSecretIdentity;

console.log(stoleSecretIdentity());
console.log(hero.getSecretIdentity());
```
What is the issue with this code and how can it be fixed.

The latter outputs the expected `John Doe`, but the former outputs `undefined` because it just copied the function without copying the `_name` attribute. Nothing wrong with this method, because I am not sure of the objective of the first `console.log`js but I am sure binding `this`js to it will fix it with either `apply()`js, `bind()`js, or `cal()`js.

23. Create a function that, given a DOM Element on the page, will visit the element itself and all of its descendents (not just its immediate children). For each element visited, the function should pass that element to a provided callback function.
The arguments to the function should be:
- a DOM element
- a callback function (that takes a DOM element as its argument)

tree traversal.
```js
const traverseDOMTree = (DOMElement) => {

	// do something with the current DOMElement

	for(let childElement of DOMElement.children)
		traverseDOMTree(childElement);

}
```

24. Testing your this knowledge in JavaScript: What is the output of the following code?
```js
var length = 10;
function fn() {
	console.log(this.length);
}

var obj = {
  length: 5,
  method: function(fn) {
    fn();
    arguments[0]();
  }
};

obj.method(fn, 1);
```

Great so is the length in the global scope or `obj` scope...
The output is:
```js
>	5
>	10
```
because `fn` in `obj.method()` refers to the callback `fn` declared globally. the first `fn()`. If I had to guess `arguments[0](1)` refers to `fn` passed. idk.

25. Consider the following code. What will the output be, and why?
```js
(function () {
    try {
        throw new Error();
    } catch (x) {
        var x = 1, y = 2;
        console.log(x);
    }
    console.log(x);
    console.log(y);
})();
```

The output will be:
```js
>	1
>	1
>	2
```
because declaring `var` scopes it between the parentheses.

26. What will be the output of this code?
```js
var x = 21;
var girl = function () {
    console.log(x);
    var x = 20;
};
girl ();
```

```js
>	21
```
`console.log(x)`js is called before re-declaring `x`, even though if `x` is hoisted within the funciton body.

27. What will this code print?
```js
for (let i = 0; i < 5; i++) {
  setTimeout(function() { console.log(i); }, i * 1000 );
}
```

Yay.
```js
>	0
>	1
>	2
>	3
>	4
```
because `let` scopes it to `i` within the timeout.

28. What do the following lines output, and why?
```js
console.log(1 < 2 < 3);
console.log(3 > 2 > 1);
```

Who even does comparators like this, but:
```js
>	True
>	True
```
idk, I am guessing it is a cursed `&&` syntactic sugar or something.

29. How do you add an element at the begining of an array? How do you add one at the end?

To add an element to the beginning of an array, use the `unshift()`js method available on an array object's prototype; `push()`js to add to the end. Note that `unshift()` is O(N).

30. Imagine you have this code:
```js
var a = [1, 2, 3];
```
a. Will this result in a crash?
a[10] = 99;
b. What will this output?
```js
console.log(a[6]);
```

a. No, it creates a sparse array with 0s between a[3] and a[9] inclusive. I am guessing.
b. **If not executing part a**: `undefined`js; **Otherwise**: `0` to be consistent with my predictions for a.

31. What is the value of typeof undefined == typeof NULL?

`false`js. Unless there is some declaration of `NULL = undefined`js or the lackof beforehand and it hasn't yet been overwritten prior to this statement, then it is `true`js.

32. What would following code return?
```js
console.log(typeof typeof 1);
```

"String". `typeof`js "number" is String.

33. What will be the output of the following code:
```js
for (var i = 0; i < 5; i++) {
	setTimeout(function() { console.log(i); }, i * 1000 );
}
```
Explain your answer. How could the use of closures help here?

```js
>	5
>	5
>	5
>	5
>	5
```
because the timeouts are set, but the value of `i` has incremented to 5 on the global scope before the async functions have been executed, and therefore take the value of `i` as 5. Since closures were mentioned, I am guessing:
```js
for (var i = 0; i < 5; i++) {
	setTimeout(function() { return function { let newI = i; return console.log(newI)}; }, i * 1000 );
}
```
assuming `let`js isn't allowed.

34. What is `NaN`? What is its type? How can you reliably test if a value is equal to `NaN`?

number? I am not sure I never tried it before. If `objectName == NaN`? idk, usually I'd just test `objectName == Number(NaN)`js

35. What will the following code output and why?
```js
var b = 1;
function outer(){
   	var b = 2
    function inner(){
        b++;
        var b = 3;
        console.log(b)
    }
    inner();
}
outer();
```

36. Discuss possible ways to write a function `isInteger(x)` that determines if `x` is an integer.

The first one comes to mind is:
```js
function isInteger(x) {

	if(!typeof x == 'number')
		return false;

	return Math.floor(x) === x;

}
```

37. How do you clone an object?

Depends if you want a deep copy, shallow copy, and whether or not ES6 syntax is allowed. But for a shallow copy, just use the assignment operator between `obj1` and `obj2`:
```js
var obj1 = obj2;
```
And destructuring with `...` (rest operator) to create deeper copies.



start `05_48.03.11`
